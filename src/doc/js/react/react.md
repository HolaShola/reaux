https://learn-reactjs.ru/basics/state-and-lifecycle  
https://github.com/facebook/react/issues/11527#issuecomment-360199710  
https://medium.com/@WoTzap  

Virtual DOM — это дерево React элементов на JavaScript. React отрисовывает Virtual DOM в браузере, чтоб сделать интерфейс видимым. React следит за изменениями в Virtual DOM и автоматически изменяет DOM в браузере так, чтоб он соответствовал виртуальному.  

Первым делом происходит рендер виртуального элемента (элемента, или компонента React). Помните, пока виртуальный элемент содержится только в памяти JavaScript. мы должны явно сообщить React отрисовать его в браузере.

React.render(<MyComponent />, document.body);

Функция render принимает два аргумента: виртуальный элемент и реальный узел DOM. React берёт виртуальный элемент и добавляет его в указанный узел. Теперь изображение можно увидеть в браузере.  

Отрисовывает элемент React в DOM в предоставленном container и вернёт ссылку на компонент (или возвращает значение null для компонентов без состояния).

Если элемент React ранее был отрисован в container, то на нем выполнится обновление и DOM изменится только при необходимости, чтобы отобразить актуальный элемент React. В последующих вызовах используется эффективный React алгоритм сравнения DOM для эффективного обновления.

Если предоставляется дополнительный коллбэк, он будет выполнен после отрисовки или обновления компонента.  

React DOM сравнивает элемент и его потомков из последнего вызова render() с элементом из предыдущего вызова render(), и применяет обновление DOM только если это необходимо, чтобы привести DOM в желаемое состояние.

Будете ли вы объявлять компонент как функцию или класс, он никогда не должен модифицировать свои свойства props. Все React-компоненты должны работать как чистые функции в отношении своих свойств “props”.  


ReactDOM.render(<Timer/>, document.getElementById('root'));  

1. Когда <Timer/> передан в ReactDOM.render(), React **вызывает конструктор** компонента Timer. 

2. Далее React вызывает метод render() компонента Timer. Далее React обновляет DOM,    в соответствии с результатом отрисовки Timer.  

3. Когда результат отрисовки Timer вставлен в DOM, React вызывает метод      componentDidMount() жизненного цикла.

4. Благодаря вызову setState(), React знает, что состояние изменилось, и вызывает метод render() снова, чтобы узнать, что должно быть на экране.  

5. Если компонент Timer в какой-то момент удалён из DOM, React вызывает метод componentWillUnmount() жизненного цикла, из-за чего таймер останавливается.

React не обновляет this.state.x до тех пор, пока компонент не будет перерисован

Передача функции обновления позволяет получить доступ к текущему значению состояния компонента внутри неё. Поскольку вызовы setState группируются, это позволяет выстраивать цепочку обновлений и обеспечивать их последовательное выполнение, избегая конфликтов.  

В редких случаях вы можете захотеть, чтобы компонент скрыл себя, даже если он был отрисован другим компонентом. Чтобы это сделать, нужно вернуть null, вместо его результата отрисовки.

Возвращение null из метода render компонента не влияет на срабатывание методов жизненного цикла компонента. К примеру, componentWillUpdate и componentDidUpdate по-прежнему будут вызываться.